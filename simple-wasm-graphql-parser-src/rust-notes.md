# Rust WASM Notes

You can build a rust web assembly package with:
- `wasm-pack build --target web`
- `wasm-pack build --target bundler`

One difference between CommonJS (CJS) and ESM is that CJS does not have top level await capabilities. Wasm packages HAVE to be imported asynchronously, so this means that with CJS, one can't use the import syntax to import the package. You have to do a fetch and initialize step in your code to handle initialize the package. ESM has top level await, so, we can just import the package and that's it (with the caveat of needing a bundler)

## To publish
To publish a rust wasm package, first we have to login with wasm-pack
```bash
wasm-pack login
```

Then we need to build prod using the script we created of compile-prod. Afterwards, we have to cd to the generated folder and run:
```bash
yarn publish --access=public
```

## Target Bundler
The `wasm-pack build --target bundler` line builds an ESM module package. This can be imported with import, but this means that we must use a bundler to load the package to project for use in a frontend. ESM are (mostly) usable in browsers through a bundler. A bundler essentially compiles all our project, including the wasm package, to one or multiple native JS files which can easily be understood by browsers. The bundler build is intended for building a package to be used with a bundler like Webpack

If we use the bundler targer build, the bundler we use determines how we import the package. Here are some example:

```javascript
// Webpack (experiments.asyncWebAssembly)
import { hello } from './my-lib.wasm'
hello()
```

```javascript
// Rollup (using @rollup/plugin-wasm)
import init from './my-lib.wasm'
init().then(({ instance }) => { instance.exports.hello() })
```

```javascript
// Parcel
import { hello } from './my-lib.wasm'
hello()
// ...or, if you want a promise
import('./my-lib.wasm').then(exports => { exports.hello() })
```

```javascript
// Vite (note: this will be removed in v3.0,
// see https://github.com/vitejs/vite/discussions/7763)
import init from './my-lib.wasm'
init().then(exports => { exports.hello() })
// alternatively, use vite-plugin-wasm, which is the preferred approach for v3+
import { hello } from './my-lib.wasm'
hello()
```

Btw, these are the JS bindings that wasm creates:

```javascript
// JS bindings generated by wasm-bindgen
import * as wasm from './my-lib_bg.wasm'
export function hello() { wasm.hello() }
```

Also, if we are using something like React, we would need to eject the project to be able to configure webpack to load our package. However, we can install the `@craco/craco` npm package anc create a `craco.config.js` file so that we don't have to eject, but still be able to tell our budler to load our .wasm file and be able to initialize them:

```javascript
const { addBeforeLoader, loaderByName } = require('@craco/craco');

module.exports = {
  webpack: {
    configure: (webpackConfig) => {
      const wasmExtensionRegExp = /\.wasm$/;
      webpackConfig.resolve.extensions.push('.wasm');

      webpackConfig.module.rules.forEach((rule) => {
        (rule.oneOf || []).forEach((oneOf) => {
          if (oneOf.loader && oneOf.loader.indexOf('file-loader') >= 0) {
            oneOf.exclude.push(wasmExtensionRegExp);
          }
        });
      });

      const wasmLoader = {
        test: /\.wasm$/,
        exclude: /node_modules/,
        loaders: ['wasm-loader'],
      };

      addBeforeLoader(webpackConfig, loaderByName('file-loader'), wasmLoader);

      return webpackConfig;
    },
  },
};
```

Finally, if we are using NextJS, it is much easier to edit the webpack as we can just edit the `next.config.js` file like so:

```javascript
module.exports = {
    reactStrictMode: true,
    webpack: function (config, options) {
        config.experiments = { asyncWebAssembly: true };
        return config;
    }
}
```



## Target Web

The `wasm-pack build --target web` produces a package that can be included in any browser. It essentially produces a CJS module

Using this, build times are faster, but maybe that doesn't matter in your use case. Something important regarding this target web build is `syncWebAssembly` and `asyncWebAssembly`, which are references to a Mozila spec [here](https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration). Sync is the old version while async is the new end improved version. This makes it that the wasm package is turned into an asynchronous ES module, which moves the initialization into the package itself. This means that packages don't have to worry about calling `initiateStreaming` to load our package asynchronously during build time. We can just import it and that's it

## Example for Frontend

We can use both builds in the frontnend. 
1. Have a project setup with webpack 
2. Install `wasm-pack-plugin`
3. Modify your `webpack.config.js` file like so
```javascript
const path = require('path')
const WasmPackPlugin = require('@wasm-tool/wasm-pack-plugin')

module.exports = {
    // ...
    plugins: [
        new WasmPackPlugin({
            crateDirectory: path.resolve(__dirname, 'crate'),

            // Check https://rustwasm.github.io/wasm-pack/book/commands/build.html for
            // the available set of arguments.
            //
            // Optional space delimited arguments to appear before the wasm-pack
            // command. Default arguments are `--verbose`.
            args: '--log-level warn',
            // Default arguments are `--typescript --target browser --mode normal`.
            // extraArgs: '--no-typescript',

            // Optional array of absolute paths to directories, changes to which
            // will trigger the build.
            // watchDirectories: [
            //   path.resolve(__dirname, "another-crate/src")
            // ],

            // The same as the `--out-dir` option for `wasm-pack`
            // outDir: "pkg",

            // The same as the `--out-name` option for `wasm-pack`
            // outName: "index",

            // If defined, `forceWatch` will force activate/deactivate watch mode for
            // `.rs` files.
            //
            // The default (not set) aligns watch mode for `.rs` files to Webpack's
            // watch mode.
            // forceWatch: true,

            // If defined, `forceMode` will force the compilation mode for `wasm-pack`
            //
            // Possible values are `development` and `production`.
            //
            // the mode `development` makes `wasm-pack` build in `debug` mode.
            // the mode `production` makes `wasm-pack` build in `release` mode.
            // forceMode: "development",

            // Controls plugin output verbosity, either 'info' or 'error'.
            // Defaults to 'info'.
            // pluginLogLevel: 'info'
        }),
    ],
    // ...
}
```

If you choose `extraArgs: '--target browser'`, you will generate an ESM module and will have to import your code like so

```javascript
import { fib } from '../../rust/pkg/fib_bg.wasm'
console.log(fib(20))
```

However, if you chose `extraArgs: '--target bundler'`, you have to import it like so:

```javascript
import("../rust/pkg").then(module => {
  console.log(module.fib(20))
});

// Or using React
import init, { fib } from '../../rust/pkg/fib_bg.wasm'

React.useEffect(() => {
  async function loadWasm() {
    await init()
    console.log(fib(20))
  }
  loadWasm();
}

```

Since we are already using a bundler in frontend, might as well use the target bundler option since it is way easier to use.

Do note that using the bundler target makes building time super slow, compared to web.

If we are using webpack and `wasm-pack-plugin`, then using asyncWebAssembly, which is an option you set in the bundler, would break the import().then() functionality. To circumvent this, we need an entry file, a bootstrap.js file of some sort, and a modified bundler config:

```javascript
// webpack.js
...
entry: {
  wasm: ['./src/bootstrap.js'],
},
experiments: {
  asyncWebAssembly: true, // This is what breaks the regular import flow
//   syncWebAssembly: true,  // Deprecated, so use asyncWebAssembly instead 
}
...

// src/bootstrap.js
import('./index.tsx').catch(e =>
  console.error('Error importing:', e),
);
```

## Example for Backend

In node, there is the `WebAssembly` object which can be used to load wasm files and instantiate them:

```javascript
const fs = require('fs');
const buf = fs.readFileSync('./addTwo.wasm');
const lib = await WebAssembly.instantiate(new Uint8Array(buf)).
  then(res => res.instance.exports);

console.log(lib.addTwo(2, 2)); // Prints '4'
console.log(lib.addTwo.toString()); // Prints 'function addTwo() { [native code] }'
```